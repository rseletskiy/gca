{"mappings":"CAAC,SAAUA,EAAQC,GACE,iBAAZC,SAA0C,oBAAXC,OAAyBF,IAC7C,mBAAXG,QAAyBA,OAAOC,IAAMD,OAAOH,GACnDA,GACH,CAJC,CAICK,GAAO,WAAc,a,SAgBjBC,EAAYC,G,IACZC,GAAS,EACTC,GAAS,EACTC,EAAW,KACXC,EAAc,CACdC,MAAA,EACAC,QAAM,EACNC,KAAA,EACAC,KAAA,EACAC,OAAM,EACNC,UAAU,EACVC,QAAA,EACFC,MAAA,EAEAC,OAAA,EAMEC,MACE,EASFC,MAAA,EACFC,UAAA,EAEA,qB,SAuBEC,EAAYC,GACd,SAAAA,OAAAC,UAAA,SAAAD,EAAAE,UAAA,SAAAF,EAAAE,UAAA,cAAAF,GAAA,aAAAA,EAAAG,U,UAqEOC,EAAqBJ,GAItBA,EAAAG,UAAAE,SAAoB,mBAG1BL,EAAAG,UAAAG,IAAA,iBAEAN,EAAAO,aAAA,+B,UAuDEC,EAASC,GACT1B,GAAS,C,CAuEb,SAAA2B,IACAT,SAAAU,iBAAA,YAAAC,GACIX,SAAOU,iBAAW,YAAsBC,GAC1CX,SAAAU,iBAAA,UAAAC,GACAX,SAAAU,iBAAA,cAAAC,GACAX,SAAAU,iBAAA,cAA0CC,GAC1CX,SAAOU,iBAAA,YAA4BC,GAEnCX,SAAAU,iBAAA,YAAAC,GACAX,SAAAU,iBAA8B,aAAAC,GAC1BX,SAAAU,iBAAA,WAAAC,EAEJ,C,iFAEEX,SAAOY,oBAAO,YAAAD,GACdX,SAAAY,oBAAA,YAAAD,GACAX,SAAQY,oBAAqB,UAAAD,GAC7BX,SAAMY,oBAAgB,cAAAD,GACxBX,SAAAY,oBAAA,cAAAD,GAEAX,SAAOY,oBAAc,YAAAD,GACtBX,SAAAY,oBAAA,YAAAD,GAEGX,SAAOY,oBACT,aAAAD,GACAX,SAAAY,oBAAA,WAAAD,G,+CAtHIH,GACAA,EAAAK,SAAAL,EAAAM,QAAAN,EAAAO,UACAjB,EAAAjB,EAAAmC,gBAAAb,EAAAtB,EAAAmC,e,GACA,E,4LAsEJ,SAAAR,GACgC,UAA1BR,SAAAiB,kBAMNlC,IAAAD,GAAA,GACA2B,IAGE,I,4CArDSD,G,IAtHUT,EACrBmB,EAEAC,EAqHErB,EAASU,EAAAY,UACTtC,IAzHmBiB,EAyHyBS,EAAAY,OAxH9CF,EAAAnB,EAAAmB,KAWe,UATfC,EAAApB,EAAAoB,UAS2BlC,EACvBiC,KAAAnB,EAAAsB,UAGE,YAAAF,IAAyBpB,EAAAsB,UAI7BtB,EAAAuB,qBAqG4CnB,EAAAK,EAAAY,O,kCAK9C,SAAAZ,G,IAzD4BT,EA2D5BD,EAAAU,EAAAY,UAQEZ,EAAAY,OAAAlB,UAAAE,SAAA,kBAAAI,EAAAY,OAAAG,aAAA,+BAQFxC,GAAA,EAEAyC,OAAAC,aAAAzC,GACAA,EAAAwC,OAAAE,YAAA,WACA3C,GAAA,EACSyC,OAAAC,aAAiBzC,EAC1B,GAAS,MAjFmBe,EAkFFS,EAAAY,QAjFtBG,aAAA,8B,YACOI,OAAA,iB,kBACP,6BAiFJ,I","sources":["src/scripts/focus-visible.js"],"sourcesContent":["(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  (factory());\r\n}(this, (function () { 'use strict';\r\n\r\n  /**\r\n   * Applies the :focus-visible polyfill at the given scope.\r\n   * A scope in this case is either the top-level Document or a Shadow Root.\r\n   *\r\n   * @param {(Document|ShadowRoot)} scope\r\n   * @see https://github.com/WICG/focus-visible\r\n   */\r\n  function applyFocusVisiblePolyfill(scope) {\r\n    var hadKeyboardEvent = true;\r\n    var hadFocusVisibleRecently = false;\r\n    var hadFocusVisibleRecentlyTimeout = null;\r\n\r\n    var inputTypesWhitelist = {\r\n      text: true,\r\n      search: true,\r\n      url: true,\r\n      tel: true,\r\n      email: true,\r\n      password: true,\r\n      number: true,\r\n      date: true,\r\n      month: true,\r\n      week: true,\r\n      time: true,\r\n      datetime: true,\r\n      'datetime-local': true\r\n    };\r\n\r\n    /**\r\n     * Helper function for legacy browsers and iframes which sometimes focus\r\n     * elements like document, body, and non-interactive SVG.\r\n     * @param {Element} el\r\n     */\r\n    function isValidFocusTarget(el) {\r\n      if (\r\n        el &&\r\n        el !== document &&\r\n        el.nodeName !== 'HTML' &&\r\n        el.nodeName !== 'BODY' &&\r\n        'classList' in el &&\r\n        'contains' in el.classList\r\n      ) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Computes whether the given element should automatically trigger the\r\n     * `focus-visible` class being added, i.e. whether it should always match\r\n     * `:focus-visible` when focused.\r\n     * @param {Element} el\r\n     * @return {boolean}\r\n     */\r\n    function focusTriggersKeyboardModality(el) {\r\n      var type = el.type;\r\n      var tagName = el.tagName;\r\n\r\n      if (tagName == 'INPUT' && inputTypesWhitelist[type] && !el.readOnly) {\r\n        return true;\r\n      }\r\n\r\n      if (tagName == 'TEXTAREA' && !el.readOnly) {\r\n        return true;\r\n      }\r\n\r\n      if (el.isContentEditable) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Add the `focus-visible` class to the given element if it was not added by\r\n     * the author.\r\n     * @param {Element} el\r\n     */\r\n    function addFocusVisibleClass(el) {\r\n      if (el.classList.contains('focus-visible')) {\r\n        return;\r\n      }\r\n      el.classList.add('focus-visible');\r\n      el.setAttribute('data-focus-visible-added', '');\r\n    }\r\n\r\n    /**\r\n     * Remove the `focus-visible` class from the given element if it was not\r\n     * originally added by the author.\r\n     * @param {Element} el\r\n     */\r\n    function removeFocusVisibleClass(el) {\r\n      if (!el.hasAttribute('data-focus-visible-added')) {\r\n        return;\r\n      }\r\n      el.classList.remove('focus-visible');\r\n      el.removeAttribute('data-focus-visible-added');\r\n    }\r\n\r\n    /**\r\n     * If the most recent user interaction was via the keyboard;\r\n     * and the key press did not include a meta, alt/option, or control key;\r\n     * then the modality is keyboard. Otherwise, the modality is not keyboard.\r\n     * Apply `focus-visible` to any current active element and keep track\r\n     * of our keyboard modality state with `hadKeyboardEvent`.\r\n     * @param {KeyboardEvent} e\r\n     */\r\n    function onKeyDown(e) {\r\n      if (e.metaKey || e.altKey || e.ctrlKey) {\r\n        return;\r\n      }\r\n\r\n      if (isValidFocusTarget(scope.activeElement)) {\r\n        addFocusVisibleClass(scope.activeElement);\r\n      }\r\n\r\n      hadKeyboardEvent = true;\r\n    }\r\n\r\n    /**\r\n     * If at any point a user clicks with a pointing device, ensure that we change\r\n     * the modality away from keyboard.\r\n     * This avoids the situation where a user presses a key on an already focused\r\n     * element, and then clicks on a different element, focusing it with a\r\n     * pointing device, while we still think we're in keyboard modality.\r\n     * @param {Event} e\r\n     */\r\n    function onPointerDown(e) {\r\n      hadKeyboardEvent = false;\r\n    }\r\n\r\n    /**\r\n     * On `focus`, add the `focus-visible` class to the target if:\r\n     * - the target received focus as a result of keyboard navigation, or\r\n     * - the event target is an element that will likely require interaction\r\n     *   via the keyboard (e.g. a text box)\r\n     * @param {Event} e\r\n     */\r\n    function onFocus(e) {\r\n      // Prevent IE from focusing the document or HTML element.\r\n      if (!isValidFocusTarget(e.target)) {\r\n        return;\r\n      }\r\n\r\n      if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\r\n        addFocusVisibleClass(e.target);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * On `blur`, remove the `focus-visible` class from the target.\r\n     * @param {Event} e\r\n     */\r\n    function onBlur(e) {\r\n      if (!isValidFocusTarget(e.target)) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        e.target.classList.contains('focus-visible') ||\r\n        e.target.hasAttribute('data-focus-visible-added')\r\n      ) {\r\n        // To detect a tab/window switch, we look for a blur event followed\r\n        // rapidly by a visibility change.\r\n        // If we don't see a visibility change within 100ms, it's probably a\r\n        // regular focus change.\r\n        hadFocusVisibleRecently = true;\r\n        window.clearTimeout(hadFocusVisibleRecentlyTimeout);\r\n        hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {\r\n          hadFocusVisibleRecently = false;\r\n          window.clearTimeout(hadFocusVisibleRecentlyTimeout);\r\n        }, 100);\r\n        removeFocusVisibleClass(e.target);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * If the user changes tabs, keep track of whether or not the previously\r\n     * focused element had .focus-visible.\r\n     * @param {Event} e\r\n     */\r\n    function onVisibilityChange(e) {\r\n      if (document.visibilityState == 'hidden') {\r\n        // If the tab becomes active again, the browser will handle calling focus\r\n        // on the element (Safari actually calls it twice).\r\n        // If this tab change caused a blur on an element with focus-visible,\r\n        // re-apply the class when the user switches back to the tab.\r\n        if (hadFocusVisibleRecently) {\r\n          hadKeyboardEvent = true;\r\n        }\r\n        addInitialPointerMoveListeners();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add a group of listeners to detect usage of any pointing devices.\r\n     * These listeners will be added when the polyfill first loads, and anytime\r\n     * the window is blurred, so that they are active when the window regains\r\n     * focus.\r\n     */\r\n    function addInitialPointerMoveListeners() {\r\n      document.addEventListener('mousemove', onInitialPointerMove);\r\n      document.addEventListener('mousedown', onInitialPointerMove);\r\n      document.addEventListener('mouseup', onInitialPointerMove);\r\n      document.addEventListener('pointermove', onInitialPointerMove);\r\n      document.addEventListener('pointerdown', onInitialPointerMove);\r\n      document.addEventListener('pointerup', onInitialPointerMove);\r\n      document.addEventListener('touchmove', onInitialPointerMove);\r\n      document.addEventListener('touchstart', onInitialPointerMove);\r\n      document.addEventListener('touchend', onInitialPointerMove);\r\n    }\r\n\r\n    function removeInitialPointerMoveListeners() {\r\n      document.removeEventListener('mousemove', onInitialPointerMove);\r\n      document.removeEventListener('mousedown', onInitialPointerMove);\r\n      document.removeEventListener('mouseup', onInitialPointerMove);\r\n      document.removeEventListener('pointermove', onInitialPointerMove);\r\n      document.removeEventListener('pointerdown', onInitialPointerMove);\r\n      document.removeEventListener('pointerup', onInitialPointerMove);\r\n      document.removeEventListener('touchmove', onInitialPointerMove);\r\n      document.removeEventListener('touchstart', onInitialPointerMove);\r\n      document.removeEventListener('touchend', onInitialPointerMove);\r\n    }\r\n\r\n    /**\r\n     * When the polfyill first loads, assume the user is in keyboard modality.\r\n     * If any event is received from a pointing device (e.g. mouse, pointer,\r\n     * touch), turn off keyboard modality.\r\n     * This accounts for situations where focus enters the page from the URL bar.\r\n     * @param {Event} e\r\n     */\r\n    function onInitialPointerMove(e) {\r\n      // Work around a Safari quirk that fires a mousemove on <html> whenever the\r\n      // window blurs, even if you're tabbing out of the page. ¯\\_(ツ)_/¯\r\n      if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {\r\n        return;\r\n      }\r\n\r\n      hadKeyboardEvent = false;\r\n      removeInitialPointerMoveListeners();\r\n    }\r\n\r\n    // For some kinds of state, we are interested in changes at the global scope\r\n    // only. For example, global pointer input, global key presses and global\r\n    // visibility change should affect the state at every scope:\r\n    document.addEventListener('keydown', onKeyDown, true);\r\n    document.addEventListener('mousedown', onPointerDown, true);\r\n    document.addEventListener('pointerdown', onPointerDown, true);\r\n    document.addEventListener('touchstart', onPointerDown, true);\r\n    document.addEventListener('visibilitychange', onVisibilityChange, true);\r\n\r\n    addInitialPointerMoveListeners();\r\n\r\n    // For focus and blur, we specifically care about state changes in the local\r\n    // scope. This is because focus / blur events that originate from within a\r\n    // shadow root are not re-dispatched from the host element if it was already\r\n    // the active element in its own scope:\r\n    scope.addEventListener('focus', onFocus, true);\r\n    scope.addEventListener('blur', onBlur, true);\r\n\r\n    // We detect that a node is a ShadowRoot by ensuring that it is a\r\n    // DocumentFragment and also has a host property. This check covers native\r\n    // implementation and polyfill implementation transparently. If we only cared\r\n    // about the native implementation, we could just check if the scope was\r\n    // an instance of a ShadowRoot.\r\n    if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {\r\n      // Since a ShadowRoot is a special kind of DocumentFragment, it does not\r\n      // have a root element to add a class to. So, we add this attribute to the\r\n      // host element instead:\r\n      scope.host.setAttribute('data-js-focus-visible', '');\r\n    } else if (scope.nodeType === Node.DOCUMENT_NODE) {\r\n      document.documentElement.classList.add('js-focus-visible');\r\n    }\r\n  }\r\n\r\n  // It is important to wrap all references to global window and document in\r\n  // these checks to support server-side rendering use cases\r\n  // @see https://github.com/WICG/focus-visible/issues/199\r\n  if (typeof window !== 'undefined' && typeof document !== 'undefined') {\r\n    // Make the polyfill helper globally available. This can be used as a signal\r\n    // to interested libraries that wish to coordinate with the polyfill for e.g.,\r\n    // applying the polyfill to a shadow root:\r\n    window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;\r\n\r\n    // Notify interested libraries of the polyfill's presence, in case the\r\n    // polyfill was loaded lazily:\r\n    var event;\r\n\r\n    try {\r\n      event = new CustomEvent('focus-visible-polyfill-ready');\r\n    } catch (error) {\r\n      // IE11 does not support using CustomEvent as a constructor directly:\r\n      event = document.createEvent('CustomEvent');\r\n      event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});\r\n    }\r\n\r\n    window.dispatchEvent(event);\r\n  }\r\n\r\n  if (typeof document !== 'undefined') {\r\n    // Apply the polyfill to the global document, so that no JavaScript\r\n    // coordination is required to use the polyfill in the top-level document:\r\n    applyFocusVisiblePolyfill(document);\r\n  }\r\n\r\n})));\r\n"],"names":["global","factory","exports","module","define","amd","this","applyFocusVisiblePolyfill","scope","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","isValidFocusTarget","el","document","nodeName","classList","addFocusVisibleClass","contains","add","setAttribute","onPointerDown","e","addInitialPointerMoveListeners","addEventListener","onInitialPointerMove","removeEventListener","metaKey","altKey","ctrlKey","activeElement","visibilityState","type","tagName","target","readOnly","isContentEditable","hasAttribute","window","clearTimeout","setTimeout","remove"],"version":3,"file":"index.14dd1153.js.map"}